<!DOCTYPE html>
<html>
  <head>
    <title>Risiko</title>
    <link rel='icon' type='image/png' href='/client/img/mappa.jpg' />
  </head>

  <body>
    <div>
      <table>
        <tr>
          <td>
            <canvas id="map" width="1296" height="729" style="background-image: url('/client/img/mappa.jpg'); border:1px solid #000000;"></canvas>
          </td>
          <td>
            <div id="chat-text" style="width:350px;height:100px;overflow-y:scroll">
              <div>Hello!</div>
            </div>
            <form id="chat-form" onsubmit="formFunction(); return false">
              <input id="chat-input" type="text" style="width:350px"></input>
            </form>
            <br>
            <div>
              Nome giocatori:
              <div id="playerlist" width="350px" style="border:1px solid #000000;"></div>
              Turno del giocatore:
              <div id="playerTurn" widht="350px" style="border:1px solid #000000;"></div>
            </div>
            <br>
          </td>
          
        </tr>
    </table>
    </div>
  
    <script type="text/javascript" src="/client/js/info.js"></script>
    <script type="text/javascript" src='https://cdn.socket.io/socket.io-1.4.5.js'></script>
    <script>
      // Recupero l'elemento canvas e il constesto del canvas della mappa.
      var canvas = document.getElementById("map");
      var context = canvas.getContext("2d");    
      var timer;  
      var players = [];  
      var nickname;

      // Aggiungo quello che ricevo alla chat.
      var chatText = document.getElementById('chat-text');
      var playerList = document.getElementById('playerList');
      var playerTurn = document.getElementById('playerTurn');

      // Recupero gli stati possibili, il territorio cliccato e lo stato corrente.
      var clientStates = playerState;
      var currentLocation;
      var currentState = clientStates.IDLE;

      // Per ogni stato in state creo una circonferenza invisibile di un certo raggio sul nome di ogni stato nella mappa.
     function initCircle() {
        states.forEach(state => {
          context.beginPath();
          context.globalAlpha = 0.0;
          context.arc(state.x, state.y, state.radius, 0, 2 * Math.PI, false);
          context.fillStyle = "rgba(255, 0,0,0.7)";
          context.fill();
        });
      };

      initCircle();

      function isIntersect(point, circle) {
        return Math.sqrt((point.x-circle.x) ** 2 + (point.y - circle.y) ** 2) < circle.radius;
      }

      function flashObject (state) {
        clearInterval(timer);
        context.clearRect(0, 0, canvas.width, canvas.height);
        initCircle();
        var count = 1000;
        timer = setInterval(function() {
          count--;
          // Alterno il disegno dei cerchi e la rimozione per fare un effetto lampeggiante.
          if (count % 2 == 1) {
            for (var neighbors in state.neighbor) {
              // Per ogni vicino disegno un cerchio rosso lampeggiante.
              states.forEach(neighborsState => {
                if (neighborsState.name == state.neighbor[neighbors]) {
                  context.beginPath();
                  context.globalAlpha = 0.5;
                  context.arc(neighborsState.x, neighborsState.y, neighborsState.radius/2, 0, 2 * Math.PI, false);
                  context.fillStyle = "red";
                  context.fill();                                            
                }
              }); 
            }
          }
          else {
            context.clearRect(0, 0, canvas.width, canvas.height);
            initCircle();
            update();
          }

          if(count == 0) {
            count = 1000;
          }
        },300);
      }

      canvas.addEventListener('click', (e) => {
        const pos = {
          x: e.clientX,
          y: e.clientY
        };
        var trovato = 0;

        // Scorro gli stati.
        states.forEach(state => {
          // Se ho cliccato su uno stato allora continuo.
          if (isIntersect(pos, state)) {
            currentLocation = state;
            console.log(state.neighbor);
            // Recupero i vicini dello stato cliccato.
            flashObject(state);
            trovato = 1;
/*
            //vedo se lo stato cliccato è mio
            if(this.player.states.includes("currentLocation"))
            {
              //sono all'interno di un mio stato
              socket.emit('myState',currentLocation); // emit an event to the socket

              //mi immagino che il server comunica al client che può muovere le truppe se ce le ha verso lo stato selezionato
              socket.on('replymyState', function(data){

                if(data == 1){//se posso muovere le truppe, variabile settata dal server che me la manda in risposta 
                socket.emit('moveTroops');
                }
                else if(data == 2){//se posso aggiungere le truppe, variabile settata dal server che me la manda in risposta 
                socket.emit('addTroops');
                }
                //finisco il turno
                player.computationState = playerState.IDLE;
                socket.emit('endTurn'); // il server deve essere in ascolto per capire quando finsice il turno    
              });
            }
            else
            {
              //lo stato non è mio
              socket.emit('notMyState', currentLocation); // emit an event to the socket
              var canAttack = false;
              //mi immagino che il server mi comunica se voglio attaccare quello stato
              socket.on('replynotmyState', function(data){

                //nel while ci starebbe messo in OR la condizione di aver cliccato il bottone termina turno
                if(data == 0) //variabile settata dal server che me la manda in risposta 
                {
                  player.computationState = playerState.ATTACK;
                  socket.emit('attackPlayer', //ID del player che attacco//); //l'ID penso che serva al server per capire contro chi mi devo scontrare
                }
                //finisco il turno
                player.computationState = playerState.IDLE;
                socket.emit('endTurn'); // il server deve essere in ascolto per capire quando finsice il turno   
              });
            }
*/
          }
        });

        // Se trovato è zero devo azzerare il timer.
        if (trovato == 0) {
          clearInterval(timer);
          context.clearRect(0, 0, canvas.width, canvas.height);
          initCircle();
          update();
        }
      });
      
      var socket = io();
     
      // Aggiungo il messaggio ricevuto alla chat.
      socket.on('addToChat', function(data) {
        chatText.innerHTML += '<div>' + data + '</div>';
      });

      // Utilizzo per debug. Ad esempio inserendo in chat /Player.list avrò la lista dei giocatori nella console.
      socket.on('evalAnswer', function(data) {
        console.log(data);
      });

      // Mi salvo il mio nickname.
      socket.on('playerInfo', function(data) {
        nickname = data;
      });

      // Gestisce un messaggio di errore mostrando un alert dedicato.
      socket.on('error', function(data) {
        var type = data;
        if (type == 'move') 
          alert("Non possiedi il territorio o i territori!");
        else if (type == 'attack')
          alert("Non puoi effettuare l'attacco, c'è qualcosa che non va!");
        else if (type == 'noTroops')
          alert("Non possiedi abbastanza truppe. \n Lo stato di partenza deve rimanere almeno con un carro armato.");
        else if (type == 'noTurn')
          alert("Non è il tuo turno. \n Attendi che ti avvisi il server.");
      });
      
      // Il server mi sta inviando le nuove informazioni da mostrare.
      socket.on('update', function(data) {
        // Pulisco il canvas.
        context.clearRect(0, 0, canvas.width, canvas.height);
        initCircle();
        players = data; 

        // Disegno le nuove informazioni.  
        update();
      });

      // Avviso il giocatore che ha conquistato lo stato e gli dico che carta ha pescato.
      socket.on('stateWon', function(data) {
        var name = data.name;
        var symbol = data.symbol;
        alert("Complimenti hai vinto tutti gli scontri e conquistato lo stato " + name + '.\nHai pescato una carta ' + symbol + ".");
      });

      // L'attaccante non è riuscito a conquistare lo stato.
      socket.on('stateNotWon', function(data) {
        var name = data.name;
        var player = data.player;
        var battle = data.battleWon;
        var total = data.totalBattle;

        if (player == nickname) {
          alert("Lo stato attaccante ha vinto " + battle + " battaglie su " + total + ".\nLo stato " + name + " rimane a te.");
        }

        else {
          alert("Lo stato attaccante ha vinto " + battle + " battaglie su " + total + ".\nLo stato " + name + " rimane a " + player + ".");
        }
        
      });

      // Avviso il giocatore che ha perso lo stato.
      socket.on('stateLost', function(data) {
        var name = data.name;
        var player = data.player;
        alert("Peccato, hai perso tutti gli scontri contro " + player + " e perso lo stato " + name + ".");
      });      

      // Funzione che viene richiamata quando viene premuto enter nell'input della chat.
      formFunction = function() {
        // Recupero gli elementi di chat.
        var chatInput = document.getElementById('chat-input');
        var chatForm = document.getElementById('chat-form');

        if (chatInput.value[0] == '/') {
          socket.emit('evalServer', chatInput.value.slice(1));
        }
        else {
          socket.emit('sendMsgToServer', chatInput.value);
        }
        // Resetto il valore della casella di chat.
        chatInput.value = '';
      };

      // Funzione che aggiorna le informazioni sullo schermo dei client.
      update = function() {
        playerList.empty();
        playerTurn.empty();
        for (var i = 0; i < players.lenght; i++) {
          for (var j = 0; j < players[i].states.lenght; j++) {
            states.forEach(state => {
              if (state.name == players[i].states[j]) {
                context.beginPath();
                context.globalAlpha = 1;
                cotext.fillStyle = players[i].color;
                //context.font="14px verdana";
                context.fillText(players[i].states[j].troop, state.x, state.y);
              }
            });
          }
          // Aggiorno sia la lista dei giocatori (in realtà basterebbe farlo solo la prima volta), il giocatore che ha il turno e cosa sta facendo.
          playerList.innerHTML += '<div style="color:' + players[i].color +'">' + players[i].nickname + '</div>';

          if (players[i].computationState != clientStates.WAITER && players[i].computationState != clientStates.IDLE) {
            if (players[i].computationState == clientStates.ASSIGN)
              playerTurn.innerHTML += '<div style="color:' + players[i].color +'">' + players[i].nickname + ', al momento sta assegnando le truppe. </div>';
            else if (players[i].computationState == clientStates.ATTACK)
              playerTurn.innerHTML += '<div style="color:' + players[i].color +'">' + players[i].nickname + ', al momento sta decidendo se fare un attacco. </div>';
            else if (players[i].computationState == clientStates.MOVE)
              playerTurn.innerHTML += '<div style="color:' + players[i].color +'">' + players[i].nickname + ', al momento sta effettuando lo spostamento finale. </div>';
          }
        }
      }
    </script>
  </body>  
</html>