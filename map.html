<!DOCTYPE html>
<html>
  <head>
    <title>Risiko</title>
    <link rel='icon' type='image/png' href='/client/img/mappa.jpg' />
  </head>

  <body>
    <div>
      <table>
        <tr>
          <td>
            <canvas id="map" width="1296" height="729" style="background-image: url('/client/img/mappa.jpg'); border:1px solid #000000;">
            </canvas>
          </td>
          <td>
            <div id="chat-text" style="width:350px;height:100px;overflow-y:scroll">
              <div>Hello!</div>
            </div>
            <form id="chat-form" onsubmit="formFunction(); return false">
              <input id="chat-input" type="text" style="width:350px"></input>
            </form>
            <br>
            <div>
              Nome giocatori:
            </div>
            <br>
          </td>
          
        </tr>
    </table>
    </div>
  
    <script type="text/javascript" src="/client/js/info.js"></script>
    <script type="text/javascript" src='https://cdn.socket.io/socket.io-1.4.5.js'></script>
    <script>
      // Recupero l'elemento canvas e il constesto del canvas.
      var canvas = document.getElementById("map");
      var context = canvas.getContext("2d");    
      var timer;  
      var players = [];  
      var nickname;

      // Recupero gli stati possibili, il territorio cliccato e lo stato corrente.
      var clientStates = playerState;
      var currentLocation;
      var currentState = clientStates.IDLE;

      // Per ogni stato in state creo una circonferenza invisibile di un certo raggio sul nome di ogni stato nella mappa.
     function initCircle() {
        states.forEach(state => {
          context.beginPath();
          context.globalAlpha = 0.0;
          context.arc(state.x, state.y, state.radius, 0, 2 * Math.PI, false);
          context.fillStyle = "rgba(255, 0,0,0.7)";
          context.fill();
        });
      };

      initCircle();

      function isIntersect(point, circle) {
        return Math.sqrt((point.x-circle.x) ** 2 + (point.y - circle.y) ** 2) < circle.radius;
      }

      //emette un cerchio negli stati vicini a quello cliccato
      function flashObject (state) {
        clearInterval(timer);
        context.clearRect(0, 0, canvas.width, canvas.height);
        initCircle();
        var count = 1000;
        timer = setInterval(function() {
          count--;
          // Alterno il disegno dei cerchi e la rimozione per fare un effetto lampeggiante.
          if (count % 2 == 1) {
            for (var neighbors in state.neighbor) {
              // Per ogni vicino disegno un cerchio rosso lampeggiante.
              states.forEach(neighborsState => {
                if (neighborsState.name == state.neighbor[neighbors]) {
                  context.beginPath();
                  context.globalAlpha = 0.5;
                  context.arc(neighborsState.x, neighborsState.y, neighborsState.radius/2, 0, 2 * Math.PI, false);
                  context.fillStyle = "red";
                  context.fill();                                            
                }
              }); 
            }
          }
          else {
            context.clearRect(0, 0, canvas.width, canvas.height);
            initCircle();
            update();
          }

          if(count == 0) {
            count = 1000;
          }
        },300);
      }

      canvas.addEventListener('click', (e) => {
        const pos = {
          x: e.clientX,
          y: e.clientY
        };
        var trovato = 0;

        // Scorro gli stati.
        states.forEach(state => {
          // Se ho cliccato su uno stato allora continuo.
          if (isIntersect(pos, state)) {
            currentLocation = state;
            console.log(state.neighbor);
            // Recupero i vicini dello stato cliccato.
            flashObject(state);
            trovato = 1;

            
            //vedo se lo stato cliccato è mio
            if(this.player.states.includes("currentLocation"))
            {
              //sono all'interno di un mio stato
              socket.emit('myState',currentLocation); // emit an event to the socket

              //mi immagino che il server comunica al client che può muovere le truppe se ce le ha verso lo stato selezionato
              socket.on('replymyState', function(data){

                if(data == 1){//se posso muovere le truppe, variabile settata dal server che me la manda in risposta 
                socket.emit('moveTroops');
                }
                else if(data == 2){//se posso aggiungere le truppe, variabile settata dal server che me la manda in risposta 
                socket.emit('addTroops');
                }
                //finisco il turno
                player.computationState = playerState.IDLE;
                socket.emit('endTurn'); // il server deve essere in ascolto per capire quando finsice il turno    
              });
            }
            else
            {
              //lo stato non è mio
              socket.emit('notMyState', currentLocation); // emit an event to the socket
              var canAttack = false;
              //mi immagino che il server mi comunica se voglio attaccare quello stato
              socket.on('replynotmyState', function(data){
                
                /*nel while ci starebbe messo in OR la condizione di aver cliccato il bottone termina turno*/
                if(data == 0) //variabile settata dal server che me la manda in risposta 
                {
                  player.computationState = playerState.ATTACK;
                  socket.emit('attackPlayer', /*ID del player che attacco*/); //l'ID penso che serva al server per capire contro chi mi devo scontrare
                }
                //finisco il turno
                player.computationState = playerState.IDLE;
                socket.emit('endTurn'); // il server deve essere in ascolto per capire quando finsice il turno   
              });
            }
          }
        });

        // Se trovato è zero devo azzerare il timer.
        if (trovato == 0) {
          clearInterval(timer);
          context.clearRect(0, 0, canvas.width, canvas.height);
          initCircle();
          update();
        }
      });


      var socket = io();

      // Aggiungo quello che ricevo alla chat.
      var chatText = document.getElementById('chat-text');
     
      socket.on('addToChat', function(data) {
        chatText.innerHTML += '<div>' + data + '</div>';
      });

      // Utilizzo per debug. Ad esempio inserendo in chat /Player.list avrò la lista dei giocatori nella console.
      socket.on('evalAnswer', function(data) {
        console.log(data);
      });

      // Mi salvo il mio nickname.
      socket.on('playerInfo', function(data) {
        nickname = data.player.nickname;
      });

      // Questi due sono messaggi di 'errore' che nel normale funzionamento non dovrebbero accadere.
      // Sono dei messaggi per prevenire l'uso di client modificati.
      socket.on('noOwner', function(data) {
        var type = data;
        if (type == 'move')
          alert("Non possiedi il territorio o i territori!");
        else if (type == 'attack')
          alert("Non puoi effettuare l'attacco, c'è qualcosa che non va!");
      });

      socket.on('noTroops', function() {
        alert("Non possiedi abbastanza truppe. \n Lo stato di partenza deve rimanere almeno con un carro armato.");
      });
      
      // Il server mi sta inviando le nuove informazioni da mostrare.
      socket.on('update', function(data) {
        // Pulisco
        context.clearRect(0, 0, canvas.width, canvas.height);
        initCircle();
        players = data.player; 
        // Disegno le nuove informazioni.  
        update();
      });

      // Avviso il giocatore che ha conquistato lo stato e gli dico che carta ha pescato.
      socket.on('stateWon', function(data) {
        var name = data.name;
        var symbol = data.symbol;
        alert("Complimenti hai vinto tutti gli scontri e conquistato lo stato " + name + '.\nHai pescato una carta ' + symbol + ".");
      });

      // L'attaccante non è riuscito a conquistare lo stato.
      socket.on('stateNotWon', function(data) {
        var name = data.name;
        var player = data.player;
        var battle = data.battleWon;
        var total = data.totalBattle;

        if (player == nickname) {
          alert("Lo stato attaccante ha vinto " + battle + "battaglie su " + total + ".\nLo stato " + name + " rimane a te.");
        }

        else {
          alert("Lo stato attaccante ha vinto " + battle + "battaglie su " + total + ".\nLo stato " + name + " rimane a " + player + ".");
        }
        
      });

      // Avviso il giocatore che ha perso lo stato.
      socket.on('stateLost', function(data) {
        var name = data.name;
        var player = data.player;
        alert("Peccato hai perso tutti gli scontri contro " + player + " e perso lo stato " + name + ".");
      });      

      formFunction = function() {
        // Recupero gli elementi di chat.
        var chatInput = document.getElementById('chat-input');
        var chatForm = document.getElementById('chat-form');

        if (chatInput.value[0] == '/') {
          socket.emit('evalServer', chatInput.value.slice(1));
        }
        else {
          socket.emit('sendMsgToServer', chatInput.value);
        }
        // Resetto il valore della casella di chat.
        chatInput.value = '';
      };

      // Funzione che aggiorna le informazioni sullo schermo dei client.
      update = function() {
        for (var i = 0; i < players.lenght; i++) {
          for (var j = 0; j < players[i].states.lenght; j++) {
            states.forEach(state => {
              if (state.name == players[i].states[j]) {
                context.beginPath();
                context.globalAlpha = 1;
                cotext.fillStyle = players[i].color;
                //context.font="14px verdana";
                context.fillText(players[i].states[j].troop, state.x, state.y);
              }
            });
          }
        }
      }
    </script>
  </body>  
</html>