<!DOCTYPE html>
<html>

<head>
  <title>Risiko</title>
  <link rel='icon' type='image/png' href='/client/img/mappa.jpg' />
</head>

<body>
  <div>
    <table>
      <tr>
        <td>
          <canvas id="map" width="1296" height="729"
            style="background-image: url('/client/img/mappa.jpg'); border:1px solid #000000;"></canvas>
        </td>
        <td>
          <div>
            <div id="playerNickname"> </div>
            <div id="playerlist" width="350px" heigth="100px" style="border:1px solid #000000;">
              <div>Nome giocatori:</div>
            </div>
            <br>
            <div id="playerTurn" widht="350px" height="1000px" style="border:1px solid #000000;">
              <div>Turno del giocatore:</div>
            </div>
            <br>
            <div id="playerSymbols" widht="350px" height="1000px" style="border:1px solid #000000;">
              <div>Carte simbolo del giocatore:</div>
            </div>
            <br>
            <div id="playerActions" widht="350px" height="1000px" style="border:1px solid #000000;">
              <div>Possibili azioni del giocatore:</div>
            </div>
            <br>
            <div id="playerSuggestions" widht="350px" height="1000px" style="border:1px solid #000000;">
              <div>Suggerimenti al giocatore:</div>
            </div>
          </div>
          <br>
          <div id="chat-text" style="width:350px;height:100px;overflow-y:scroll">
            <div>Connesso alla chat!</div>
          </div>
          <form id="chat-form" onsubmit="formFunction(); return false">
            <input id="chat-input" type="text" style="width:350px"></input>
          </form>
        </td>

      </tr>
    </table>
  </div>
  <script>
    var exports = {};
  </script>
  <script type="text/javascript" src="/client/js/info.js"></script>
  <script type="text/javascript" src='https://cdn.socket.io/socket.io-1.4.5.js'></script>
  <script>
    // Recupero l'elemento canvas e il constesto del canvas della mappa.
    var canvas = document.getElementById("map");
    var context = canvas.getContext("2d");
    var timer;
    var players = [];

    // Recupero il mio nickname tramite URL.
    var ref = window.location.href;
    var url = ref.split("=");
    var nickname = url[1];
    document.getElementById('playerNickname').innerHTML += "<h3> Il tuo nickaname è " + nickname + "</h3>";


    // Aggiungo quello che ricevo alla chat.
    var chatText = document.getElementById('chat-text');
    var playerList = document.getElementById('playerList');
    var playerTurn = document.getElementById('playerTurn');
    var platerSymbols = document.getElementById('playerSymbols');
    var playerActions = document.getElementById('playerActions');
    var playerSuggestions = document.getElementById('playerSuggestions');

    // Recupero gli stati possibili, il territorio cliccato e lo stato corrente.
    var clientStates = playerState;
    var currentLocation;
    var currentState = clientStates.IDLE;


    // Per ogni stato in state creo una circonferenza invisibile di un certo raggio sul nome di ogni stato nella mappa.
    function initCircle() {
      states.forEach(state => {
        context.beginPath();
        context.globalAlpha = 0.0;
        context.arc(state.x, state.y, state.radius, 0, 2 * Math.PI, false);
        context.fillStyle = "rgba(255, 0,0,0.7)";
        context.fill();
      });
    };

    initCircle();

    function isIntersect(point, circle) {
      return Math.sqrt((point.x - circle.x) ** 2 + (point.y - circle.y) ** 2) < circle.radius;
    }

    function flashObject(state) {
      clearInterval(timer);
      context.clearRect(0, 0, canvas.width, canvas.height);
      initCircle();
      var count = 1000;
      timer = setInterval(function () {
        count--;
        // Alterno il disegno dei cerchi e la rimozione per fare un effetto lampeggiante.
        if (count % 2 == 1) {
          for (var neighbors in state.neighbor) {
            // Per ogni vicino disegno un cerchio rosso lampeggiante.
            states.forEach(neighborsState => {
              if (neighborsState.name == state.neighbor[neighbors]) {
                context.beginPath();
                context.globalAlpha = 0.5;
                context.arc(neighborsState.x, neighborsState.y, neighborsState.radius / 2, 0, 2 * Math.PI,
                  false);
                context.fillStyle = "red";
                context.fill();
              }
            });
          }
        } else {
          context.clearRect(0, 0, canvas.width, canvas.height);
          initCircle();
          update();
        }

        if (count == 0) {
          count = 1000;
        }
      }, 300);
    }

    canvas.addEventListener('click', (e) => {
      const pos = {
        x: e.clientX,
        y: e.clientY
      };
      var trovato = 0;

      // Scorro gli stati.
      states.forEach(state => {
        // Se ho cliccato su uno stato allora continuo.
        if (isIntersect(pos, state)) {
          currentLocation = state;
          console.log(state.neighbor);
          // Recupero i vicini dello stato cliccato.
          flashObject(state);
          trovato = 1;

          //vedo se lo stato cliccato è mio
          if (this.player.states.includes("currentLocation")) {
            //if(player.nickname == currentLocation.owner) oppure cosi forse 
            //sono all'interno di un mio stato
            if (computationState == playerState.WAITER || computationState == playerState.IDLE) {
              //un fa nu cazz
              alert("attendi il tuo turno");
            } else if (computationState == playerState.ASSIGN) {
              socket.emit('addTroop');
            } else if (computationState == playerState.MOVE) {
              socket.emit('moveTroops');
            }
          } else {
            //lo stato non è mio e sono in modalità attacco
            if (computationState == playerState.ATTACK) {
              //se ci clicco due volte allora comincio ad attaccare facendo i dovuti controlli
              currentLocation.addEventListener("dblclick", function (data) {
                var attacker = Player.find(data.attacker);
                var defender = Player.find(data.defender);
                var attackerState = states.find(item => item.name == data.state1);
                var defenderState = states.find(item => item.name == data.state2);
                if ((attacker.nickname == attackerState.owner) && (defender.nickname == defenderState.owner)) {
                  // Devo anche controllare che i due stati siano confinanti.
                  if (attackerState.neighbor.includes(defenderState)) {
                    socket.emit('attackPlayer', defenderState);
                    socket.emit('endMove'); //termino la mossa
                  } else {
                    alert("unni spacchio clicchi? cercati un vicino");
                  }
                }
              });
            } else {
              //un fa nu cazz
              alert("ma sei down? non tocca a te, va fatti un cappuccino");
            }
          }
        }
      });

      // Se trovato è zero devo azzerare il timer.
      if (trovato == 0) {
        clearInterval(timer);
        context.clearRect(0, 0, canvas.width, canvas.height);
        initCircle();
        update();
      }
    });





    var socket = io();

    // Avviso il server che da ora deve comunicare con me tramite questa socket.
    socket.emit('newSocket', nickname);

    // Aggiungo il messaggio ricevuto alla chat.
    socket.on('addToChat', function (data) {
      chatText.innerHTML += '<div>' + data + '</div>';
    });

    // Utilizzo per debug. Ad esempio inserendo in chat /Player.list avrò la lista dei giocatori nella console.
    socket.on('evalAnswer', function (data) {
      console.log(data);
    });

    // Gestisce un messaggio di errore mostrando un alert dedicato.
    socket.on('error', function (data) {
      var type = data;
      if (type == 'move')
        alert("Non possiedi il territorio o i territori!");
      else if (type == 'attack')
        alert("Non puoi effettuare l'attacco, c'è qualcosa che non va!");
      else if (type == 'noTroops')
        alert(
          "Non possiedi abbastanza truppe. \n Lo stato di partenza deve rimanere almeno con un carro armato."
        );
      else if (type == 'noTurn')
        alert("Non è il tuo turno. \n Attendi che ti avvisi il server.");
      else if (type == 'noNeighbor')
        alert("I due stati non sono confinanti.");
    });

    // Il server mi sta inviando le nuove informazioni da mostrare.
    socket.on('update', function (data) {
      // Pulisco il canvas.
      context.clearRect(0, 0, canvas.width, canvas.height);
      initCircle();
      players = data;
      playerList.empty();
      playerTurn.empty();
      playerSymbols.empty();
      playerSuggestions.empty();
      playerActions.empty();

      // Disegno le nuove informazioni.  
      update();
    });

    // Avviso il giocatore che ha conquistato lo stato e gli dico che carta ha pescato.
    socket.on('stateWon', function (data) {
      var name = data.name;
      var symbol = data.symbol;
      alert("Complimenti hai vinto tutti gli scontri e conquistato lo stato " + name +
        '.\nHai pescato una carta ' +
        symbol + ".");
    });

    // L'attaccante non è riuscito a conquistare lo stato.
    socket.on('stateNotWon', function (data) {
      var name = data.name;
      var player = data.player;
      var battle = data.battleWon;
      var total = data.totalBattle;

      if (player == nickname) {
        alert("Lo stato attaccante ha vinto " + battle + " battaglie su " + total + ".\nLo stato " +
          name +
          " rimane a te.");
      } else {
        alert("Lo stato attaccante ha vinto " + battle + " battaglie su " + total + ".\nLo stato " +
          name +
          " rimane a " + player + ".");
      }

    });

    // Avviso il giocatore che ha perso lo stato.
    socket.on('stateLost', function (data) {
      var name = data.name;
      var player = data.player;
      alert("Peccato, hai perso tutti gli scontri contro " + player + " e perso lo stato " + name +
        ".");
    });

    // Funzione per terminare la fase di attacco.
    endAttackFunction = function () {
      socket.emit('endAttack');
    }

    // Funzione per terminare la fase di spostamento.
    endMoveFunction = function () {
      socket.emit('endMove');
    }

    // Funzione per scambiare le carte simbolo per carri armati.
    exchangeFunction = function (symbolType, array) {
      socket.emit('exchangeSymbol', {
        combination: symbolType,
        array: array
      });
    }

    // Funzione che viene richiamata quando viene premuto enter nell'input della chat.
    formFunction = function () {
      // Recupero gli elementi di chat.
      var chatInput = document.getElementById('chat-input');
      var chatForm = document.getElementById('chat-form');

      if (chatInput.value[0] == '/') {
        socket.emit('evalServer', chatInput.value.slice(1));
      } else {
        socket.emit('sendMsgToServer', chatInput.value);
      }
      // Resetto il valore della casella di chat.
      chatInput.value = '';
    };

    // Funzione che aggiorna le informazioni sullo schermo dei client.
    update = function () {
      for (var i = 0; i < players.lenght; i++) {
        for (var j = 0; j < players[i].states.lenght; j++) {
          states.forEach(state => {
            if (state.name == players[i].states[j]) {
              context.beginPath();
              context.globalAlpha = 1;
              cotext.fillStyle = players[i].color;
              //context.font="14px verdana";
              context.fillText(players[i].states[j].troop, state.x, state.y);
            }
          });
        }
        // Se mi riconosco aggiorno il mio stato.
        if (players[i].nickname == nickname)
          currentState = players[i].computationState;

        // Aggiorno la lista dei giocatori.
        playerList.innerHTML += '<div style="color:' + players[i].color + '">' + players[i].nickname +
          '</div>';

        // Aggiorno la lista delle carte simbolo del giocatore.
        var count = (input, arr) => arr.filter(x => x == input).length;
        countCannoni = count(symbols.Cannone, player.symbols);
        countFanti = count(symbols.Fante, player.symbols);
        countCavalieri = count(symbols.Cavaliere, player.symbols);

        playerSymbols.innerHTML += "<div>" + countCannoni + "</div>";
        playerSymbols.innerHTML += "<div>" + countFanti + "</div>";
        playerSymbols.innerHTML += "<div>" + countCavalieri + "</div>";

        // Aggiorno il client di cosa sta facendo il giocatore in turno, la sezione suggerimenti per ogni mossa e la sezione azioni possibili.
        if (players[i].computationState == clientStates.ASSIGN) {
          playerTurn.innerHTML += '<div style="color:' + players[i].color + '">' + players[i].nickname +
            ', al momento sta assegnando le truppe. </div>';
          playerSuggestions.innerHTML += '<div>' + suggestions.ASSIGN + '</div>';

          if (players[i].nickname == nickname)
            playerTurn.innerHTML += '<div style="color:' + players[i].color + '> Ti rimangono ' +
            players[
              i].troop +
            ' da assegnare. </div>';

          // Verifico se devo inserire i bottoni per lo scambio delle truppe.
          if (countCannoni >= 3)
            playerActions.innerHTML +=
            "<button onclick=exchangeFunction(symbols.Cannone, null)'>Scambia tre Cannoni per 4 truppe.</button>";
          if (countFanti >= 3)
            playerActions.innerHTML +=
            "<button onclick=exchangeFunction(symbols.Fante, null)'>Scambia tre Fanti per 6 truppe.</button>";
          if (countCavalieri >= 3)
            playerActions.innerHTML +=
            "<button onclick=exchangeFunction(symbols.Cavaliere, null)'>Scambia tre Cavalieri per 8 truppe.</button>";
          if ((countCannoni > 0) && (countFanti > 0) && (countCavalieri > 0))
            playerActions.innerHTML +=
            "<button onclick=exchangeFunction(symbols.Diversi, null)'>Scambia un Cannone, un Fante e un Cavaliere per 10 truppe.</button>";
          // Se è disponibile la combinazione due cannoni e un fante.
          if ((countCannoni >= 2) && (countFanti != 0)) {
            var array = [symbols.Cannone, symbols.Fante];
            playerActions.innerHTML += "<button onclick=exchangeFunction(symbols.Jolly," + array +
              ")'>Scambia due Cannoni e un Fante per 12 truppe.</button>";
          }
          // Se è disponibile la combinazione due cannoni e un cavaliere.
          if ((countCannoni >= 2) && (countCavalieri != 0)) {
            var array = [symbols.Cannone, symbols.Cavaliere];
            playerActions.innerHTML += "<button onclick=exchangeFunction(symbols.Jolly," + array +
              ")'>Scambia due Cannoni e un Cavaliere per 12 truppe.</button>";
          }
          // Se è disponibile la combinazione due fanti e un cannone.
          if ((countFanti >= 2) && (countCannoni != 0)) {
            var array = [symbols.Fante, symbols.Cannone];
            playerActions.innerHTML += "<button onclick=exchangeFunction(symbols.Jolly," + array +
              ")'>Scambia due Fanti e un Cannone per 12 truppe.</button>";
          }
          // Se è disponibile la combinazione due fanti e un cavaliere.
          if ((countFanti >= 2) && (countCavalieri != 0)) {
            var array = [symbols.Fante, symbols.Cavaliere];
            playerActions.innerHTML += "<button onclick=exchangeFunction(symbols.Jolly," + array +
              ")'>Scambia due Fanti e un Cavaliere per 12 truppe.</button>";
          }
          // Se è disponibile la combinazione due cavalieri e un cannone.
          if ((countCavalieri >= 2) && (countCannoni != 0)) {
            var array = [symbols.Cavaliere, symbols.Cannone];
            playerActions.innerHTML += "<button onclick=exchangeFunction(symbols.Jolly," + array +
              ")'>Scambia due Cavalieri e un Cannone per 12 truppe.</button>";
          }
          // Se è disponibile la combinazione due cavalieri e un fante.
          if ((countCavalieri >= 2) && (countFanti != 0)) {
            var array = [symbols.Cavaliere, symbols.Fante];
            playerActions.innerHTML += "<button onclick=exchangeFunction(symbols.Jolly," + array +
              ")'>Scambia due Cavalieri e un Fante per 12 truppe.</button>";
          }
        } else if (players[i].computationState == clientStates.ATTACK) {
          playerTurn.innerHTML += '<div style="color:' + players[i].color + '">' + players[i].nickname +
            ', al momento sta decidendo se fare un attacco. </div>';
          playerSuggestions.innerHTML += '<div>' + suggestions.ATTACK + '</div>';
          playerActions.innerHTML +=
            "<button onclick=endAttackFunction()'>Termina fase di attacco</button>";
        } else if (players[i].computationState == clientStates.MOVE) {
          playerTurn.innerHTML += '<div style="color:' + players[i].color + '">' + players[i].nickname +
            ', al momento sta effettuando lo spostamento finale. </div>';
          playerSuggestions.innerHTML += '<div>' + suggestions.MOVE + '</div>';
          playerActions.innerHTML +=
            "<button onclick=endMoveFunction()'>Termina fase di spostamento</button>";
        }
        // Aggiorno la sezione suggerimenti dei giocatori in attesa e in stato idle.
        else if (players[i].computationState == clientStates.WAITER) {
          playerSuggestions.innerHTML += '<div>' + suggestions.WAITER + '</div>';
        } else if (players[i].computationState == clientStates.IDLE) {
          playerSuggestions.innerHTML += '<div>' + suggestions.IDLE + '</div>';
        }
      }
    }
  </script>
</body>

</html>